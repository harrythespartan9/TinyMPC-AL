#include <math.h>
void tiny_Bicycle3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.16666666666666666 * (0.4 * cos(0.05 * tan(u[1]) * u[0] + x[2]) + 0.1 * cos(0.1 * tan(u[1]) * u[0] + x[2]) + 0.1 * cos(x[2]) + -0.010000000000000002 * sin(0.1 * tan(u[1]) * u[0] + x[2]) * tan(u[1]) * u[0] + -0.020000000000000004 * sin(0.05 * tan(u[1]) * u[0] + x[2]) * tan(u[1]) * u[0]);
  B[1] = 0.16666666666666666 * (0.4 * sin(0.05 * tan(u[1]) * u[0] + x[2]) + 0.1 * sin(0.1 * tan(u[1]) * u[0] + x[2]) + 0.1 * sin(x[2]) + 0.020000000000000004 * cos(0.05 * tan(u[1]) * u[0] + x[2]) * tan(u[1]) * u[0] + 0.010000000000000002 * cos(0.1 * tan(u[1]) * u[0] + x[2]) * tan(u[1]) * u[0]);
  B[2] = 0.09999999999999999 * tan(u[1]);
  B[3] = 0.16666666666666666 * (-0.010000000000000002 * (1 + pow(tan(u[1]), 2)) * pow(u[0], 2) * sin(0.1 * tan(u[1]) * u[0] + x[2]) + -0.020000000000000004 * (1 + pow(tan(u[1]), 2)) * pow(u[0], 2) * sin(0.05 * tan(u[1]) * u[0] + x[2]));
  B[4] = 0.16666666666666666 * (0.010000000000000002 * (1 + pow(tan(u[1]), 2)) * pow(u[0], 2) * cos(0.1 * tan(u[1]) * u[0] + x[2]) + 0.020000000000000004 * (1 + pow(tan(u[1]), 2)) * pow(u[0], 2) * cos(0.05 * tan(u[1]) * u[0] + x[2]));
  B[5] = 0.09999999999999999 * (1 + pow(tan(u[1]), 2)) * u[0];
}

// CLARI AIS Kinematic model (2024/04/25) 11:10AM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 5Hz; H = 0.2;
// # ==================== uses the typical midpoint method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.00028500000000000004 * cos(0.0475 * u[1] + x[2]);
  B[1] = 0.00028500000000000004 * sin(0.0475 * u[1] + x[2]);
  B[2] = 0;
  B[3] = -1.3537500000000002e-5 * u[0] * sin(0.0475 * u[1] + x[2]);
  B[4] = 1.3537500000000002e-5 * u[0] * cos(0.0475 * u[1] + x[2]);
  B[5] = 0.095;
}

// CLARI AIS Kinematic model (2024/04/30) 9:45AM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 5Hz;
// # ==================== H = 0.2; H_phi = 0.1; N = 2;
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.00028500000000000004 * cos(0.095 * u[1] + x[2]) + 0.00028500000000000004 * cos(x[2]);
  B[1] = 0.00028500000000000004 * sin(0.095 * u[1] + x[2]) + 0.00028500000000000004 * sin(x[2]);
  B[2] = 0;
  B[3] = -2.7075000000000004e-5 * u[0] * sin(0.095 * u[1] + x[2]);
  B[4] = 2.7075000000000004e-5 * u[0] * cos(0.095 * u[1] + x[2]);
  B[5] = 0.19;
}

// CLARI AIS Kinematic model (2024/04/30) 10:35AM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 5Hz;
// # ==================== H = 0.2; H_phi = 0.1; N = 2;
// # ==================== uses the gait-averaged midpoint method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.00028500000000000004 * cos(0.095 * u[1] + x[2]) + 0.00028500000000000004 * cos(0.19 * u[1] + x[2]);
  B[1] = 0.00028500000000000004 * sin(0.095 * u[1] + x[2]) + 0.00028500000000000004 * sin(0.19 * u[1] + x[2]);
  B[2] = 0;
  B[3] = -2.7075000000000004e-5 * u[0] * sin(0.095 * u[1] + x[2]) + -5.415000000000001e-5 * u[0] * sin(0.19 * u[1] + x[2]);
  B[4] = 2.7075000000000004e-5 * u[0] * cos(0.095 * u[1] + x[2]) + 5.415000000000001e-5 * u[0] * cos(0.19 * u[1] + x[2]);
  B[5] = 0.19;
}

// CLARI AIS Kinematic model (2024/04/30) 10:48AM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 5Hz;
// # ==================== H = 0.2; H_phi = 0.1; N = 2;
// # ==================== uses the gait-averaged RK4 method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.16666666666666666 * (0.00028500000000000004 * cos(0.28500000000000003 * u[1] + x[2]) + 0.00028500000000000004 * cos(0.095 * u[1] + x[2]) + 4 * (0.00028500000000000004 * cos(0.095 * u[1] + x[2]) + 0.00028500000000000004 * cos(0.19 * u[1] + x[2])) + 0.00028500000000000004 * cos(0.19 * u[1] + x[2]) + 0.00028500000000000004 * cos(x[2]));
  B[1] = 0.16666666666666666 * (4 * (0.00028500000000000004 * sin(0.095 * u[1] + x[2]) + 0.00028500000000000004 * sin(0.19 * u[1] + x[2])) + 0.00028500000000000004 * sin(0.095 * u[1] + x[2]) + 0.00028500000000000004 * sin(0.19 * u[1] + x[2]) + 0.00028500000000000004 * sin(x[2]) + 0.00028500000000000004 * sin(0.28500000000000003 * u[1] + x[2]));
  B[2] = 0;
  B[3] = 0.16666666666666666 * (-2.7075000000000004e-5 * u[0] * sin(0.095 * u[1] + x[2]) + 4 * (-2.7075000000000004e-5 * u[0] * sin(0.095 * u[1] + x[2]) + -5.415000000000001e-5 * u[0] * sin(0.19 * u[1] + x[2])) + -5.415000000000001e-5 * u[0] * sin(0.19 * u[1] + x[2]) + -8.122500000000002e-5 * u[0] * sin(0.28500000000000003 * u[1] + x[2]));
  B[4] = 0.16666666666666666 * (8.122500000000002e-5 * u[0] * cos(0.28500000000000003 * u[1] + x[2]) + 2.7075000000000004e-5 * u[0] * cos(0.095 * u[1] + x[2]) + 4 * (2.7075000000000004e-5 * u[0] * cos(0.095 * u[1] + x[2]) + 5.415000000000001e-5 * u[0] * cos(0.19 * u[1] + x[2])) + 5.415000000000001e-5 * u[0] * cos(0.19 * u[1] + x[2]));
  B[5] = 0.19;
}

