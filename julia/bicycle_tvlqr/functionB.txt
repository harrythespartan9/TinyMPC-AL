#include <math.h>
void tiny_Bicycle3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.16666666666666666 * (0.4 * cos(0.05 * tan(u[1]) * u[0] + x[2]) + 0.1 * cos(0.1 * tan(u[1]) * u[0] + x[2]) + 0.1 * cos(x[2]) + -0.010000000000000002 * sin(0.1 * tan(u[1]) * u[0] + x[2]) * tan(u[1]) * u[0] + -0.020000000000000004 * sin(0.05 * tan(u[1]) * u[0] + x[2]) * tan(u[1]) * u[0]);
  B[1] = 0.16666666666666666 * (0.4 * sin(0.05 * tan(u[1]) * u[0] + x[2]) + 0.1 * sin(0.1 * tan(u[1]) * u[0] + x[2]) + 0.1 * sin(x[2]) + 0.020000000000000004 * cos(0.05 * tan(u[1]) * u[0] + x[2]) * tan(u[1]) * u[0] + 0.010000000000000002 * cos(0.1 * tan(u[1]) * u[0] + x[2]) * tan(u[1]) * u[0]);
  B[2] = 0.09999999999999999 * tan(u[1]);
  B[3] = 0.16666666666666666 * (-0.010000000000000002 * (1 + pow(tan(u[1]), 2)) * pow(u[0], 2) * sin(0.1 * tan(u[1]) * u[0] + x[2]) + -0.020000000000000004 * (1 + pow(tan(u[1]), 2)) * pow(u[0], 2) * sin(0.05 * tan(u[1]) * u[0] + x[2]));
  B[4] = 0.16666666666666666 * (0.010000000000000002 * (1 + pow(tan(u[1]), 2)) * pow(u[0], 2) * cos(0.1 * tan(u[1]) * u[0] + x[2]) + 0.020000000000000004 * (1 + pow(tan(u[1]), 2)) * pow(u[0], 2) * cos(0.05 * tan(u[1]) * u[0] + x[2]));
  B[5] = 0.09999999999999999 * (1 + pow(tan(u[1]), 2)) * u[0];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/04/25) 11:10AM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 5Hz; H = 0.2;
// # ==================== uses the typical midpoint method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.00028500000000000004 * cos(0.0475 * u[1] + x[2]);
  B[1] = 0.00028500000000000004 * sin(0.0475 * u[1] + x[2]);
  B[2] = 0;
  B[3] = -1.3537500000000002e-5 * u[0] * sin(0.0475 * u[1] + x[2]);
  B[4] = 1.3537500000000002e-5 * u[0] * cos(0.0475 * u[1] + x[2]);
  B[5] = 0.095;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/04/30) 9:45AM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 5Hz;
// # ==================== H = 0.2; H_phi = 0.1; N = 2;
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.00028500000000000004 * cos(0.095 * u[1] + x[2]) + 0.00028500000000000004 * cos(x[2]);
  B[1] = 0.00028500000000000004 * sin(0.095 * u[1] + x[2]) + 0.00028500000000000004 * sin(x[2]);
  B[2] = 0;
  B[3] = -2.7075000000000004e-5 * u[0] * sin(0.095 * u[1] + x[2]);
  B[4] = 2.7075000000000004e-5 * u[0] * cos(0.095 * u[1] + x[2]);
  B[5] = 0.19;
}

// CLARI AIS Kinematic model (2024/04/30) 10:35AM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 5Hz;
// # ==================== H = 0.2; H_phi = 0.1; N = 2;
// # ==================== uses the gait-averaged midpoint method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.00028500000000000004 * cos(0.095 * u[1] + x[2]) + 0.00028500000000000004 * cos(0.19 * u[1] + x[2]);
  B[1] = 0.00028500000000000004 * sin(0.095 * u[1] + x[2]) + 0.00028500000000000004 * sin(0.19 * u[1] + x[2]);
  B[2] = 0;
  B[3] = -2.7075000000000004e-5 * u[0] * sin(0.095 * u[1] + x[2]) + -5.415000000000001e-5 * u[0] * sin(0.19 * u[1] + x[2]);
  B[4] = 2.7075000000000004e-5 * u[0] * cos(0.095 * u[1] + x[2]) + 5.415000000000001e-5 * u[0] * cos(0.19 * u[1] + x[2]);
  B[5] = 0.19;
}

// CLARI AIS Kinematic model (2024/04/30) 10:48AM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 5Hz;
// # ==================== H = 0.2; H_phi = 0.1; N = 2;
// # ==================== uses the gait-averaged RK4 method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.16666666666666666 * (0.00028500000000000004 * cos(0.28500000000000003 * u[1] + x[2]) + 0.00028500000000000004 * cos(0.095 * u[1] + x[2]) + 4 * (0.00028500000000000004 * cos(0.095 * u[1] + x[2]) + 0.00028500000000000004 * cos(0.19 * u[1] + x[2])) + 0.00028500000000000004 * cos(0.19 * u[1] + x[2]) + 0.00028500000000000004 * cos(x[2]));
  B[1] = 0.16666666666666666 * (4 * (0.00028500000000000004 * sin(0.095 * u[1] + x[2]) + 0.00028500000000000004 * sin(0.19 * u[1] + x[2])) + 0.00028500000000000004 * sin(0.095 * u[1] + x[2]) + 0.00028500000000000004 * sin(0.19 * u[1] + x[2]) + 0.00028500000000000004 * sin(x[2]) + 0.00028500000000000004 * sin(0.28500000000000003 * u[1] + x[2]));
  B[2] = 0;
  B[3] = 0.16666666666666666 * (-2.7075000000000004e-5 * u[0] * sin(0.095 * u[1] + x[2]) + 4 * (-2.7075000000000004e-5 * u[0] * sin(0.095 * u[1] + x[2]) + -5.415000000000001e-5 * u[0] * sin(0.19 * u[1] + x[2])) + -5.415000000000001e-5 * u[0] * sin(0.19 * u[1] + x[2]) + -8.122500000000002e-5 * u[0] * sin(0.28500000000000003 * u[1] + x[2]));
  B[4] = 0.16666666666666666 * (8.122500000000002e-5 * u[0] * cos(0.28500000000000003 * u[1] + x[2]) + 2.7075000000000004e-5 * u[0] * cos(0.095 * u[1] + x[2]) + 4 * (2.7075000000000004e-5 * u[0] * cos(0.095 * u[1] + x[2]) + 5.415000000000001e-5 * u[0] * cos(0.19 * u[1] + x[2])) + 5.415000000000001e-5 * u[0] * cos(0.19 * u[1] + x[2]));
  B[5] = 0.19;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/04/30) 4:33PM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = 10Hz;
// # ==================== H = 0.1; H_phi = 0.05; N = 2;
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.00014250000000000002 * cos(0.0475 * u[1] + x[2]) + 0.00014250000000000002 * cos(x[2]);
  B[1] = 0.00014250000000000002 * sin(x[2]) + 0.00014250000000000002 * sin(0.0475 * u[1] + x[2]);
  B[2] = 0;
  B[3] = -6.768750000000001e-6 * u[0] * sin(0.0475 * u[1] + x[2]);
  B[4] = 6.768750000000001e-6 * u[0] * cos(0.0475 * u[1] + x[2]);
  B[5] = 0.095;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/04/30) 5:13PM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = 10Hz;
// # ==================== H = 0.1; H_phi = 0.05; N = 2;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.00014250000000000002 * x[2] + 0.00014250000000000002 * (x[2] + -0.0475 * u[1] * x[3]);
  B[1] = 0.00014250000000000002 * x[3] + 0.00014250000000000002 * (x[3] + 0.0475 * u[1] * x[2]);
  B[2] = 0;
  B[3] = 0;
  B[4] = -6.768750000000001e-6 * u[0] * x[3];
  B[5] = 6.768750000000001e-6 * u[0] * x[2];
  B[6] = -0.0475 * x[3] + -0.0475 * (x[3] + 0.0475 * u[1] * x[2]) + -0.00225625 * u[1] * x[2];
  B[7] = 0.0475 * x[2] + -0.00225625 * u[1] * x[3] + 0.0475 * (x[2] + -0.0475 * u[1] * x[3]);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/05/01) 8:00AM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = 20Hz;
// # ==================== H = 0.05; H_phi = 0.05; N = 1;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.00014250000000000002 * x[2];
  B[1] = 0.00014250000000000002 * x[3];
  B[2] = 0;
  B[3] = 0;
  B[4] = 0;
  B[5] = 0;
  B[6] = -0.0475 * x[3];
  B[7] = 0.0475 * x[2];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/05/03) 1:48AM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = 20Hz;
// # ==================== H = 0.05; H_phi = 0.05; N = 1;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== inputs: [translation_control, rotation_control, swing_control]
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.00014250000000000002 * u[2] * x[2];
  B[1] = 0.00014250000000000002 * u[2] * x[3];
  B[2] = 0;
  B[3] = 0;
  B[4] = 0;
  B[5] = 0;
  B[6] = -0.0475 * u[2] * x[3];
  B[7] = 0.0475 * u[2] * x[2];
  B[8] = 0.00014250000000000002 * u[0] * x[2];
  B[9] = 0.00014250000000000002 * u[0] * x[3];
  B[10] = -0.0475 * u[1] * x[3];
  B[11] = 0.0475 * u[1] * x[2];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/05/05) 9:28PM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = <NOT_CONSTRAINED>;
// # ==================== H_phi = 0.05; N = <UNKNOWN>;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== inputs: [translation_control, rotation_control, swing_control]
// # ==================== uses the rk4 method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.16666666666666666 * (0.00028500000000000004 * u[2] * x[2] + 0.0005700000000000001 * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2] + 0.0005700000000000001 * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2] + 0.00028500000000000004 * (x[2] + -0.095 * u[1] * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2]) * u[2]);
  B[1] = 0.16666666666666666 * (0.00028500000000000004 * u[2] * x[3] + 0.0005700000000000001 * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2] + 0.0005700000000000001 * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2] + 0.00028500000000000004 * (x[3] + 0.095 * u[1] * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2]) * u[2]);
  B[2] = 0;
  B[3] = 0;
  B[4] = 0.16666666666666666 * (-2.7075000000000004e-5 * u[0] * pow(u[2], 2) * x[3] + 0.0005700000000000001 * u[0] * (-0.00225625 * u[1] * pow(u[2], 2) * x[2] + -0.0475 * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2] + 0.00028500000000000004 * u[0] * (-0.095 * u[1] * (-0.00225625 * u[1] * pow(u[2], 2) * x[3] + 0.0475 * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2] + -0.095 * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2]) * u[2]);
  B[5] = 0.16666666666666666 * (2.7075000000000004e-5 * u[0] * pow(u[2], 2) * x[2] + 0.0005700000000000001 * u[0] * (-0.00225625 * u[1] * pow(u[2], 2) * x[3] + 0.0475 * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2] + 0.00028500000000000004 * u[0] * (0.095 * u[1] * (-0.00225625 * u[1] * pow(u[2], 2) * x[2] + -0.0475 * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2] + 0.095 * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2]) * u[2]);
  B[6] = 0.16666666666666666 * (-0.095 * u[2] * x[3] + -0.009025 * u[1] * pow(u[2], 2) * x[2] + -0.19 * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2] + -0.19 * u[1] * (-0.00225625 * u[1] * pow(u[2], 2) * x[3] + 0.0475 * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2] + -0.19 * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2] + -0.095 * u[1] * (0.095 * u[1] * (-0.00225625 * u[1] * pow(u[2], 2) * x[2] + -0.0475 * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2] + 0.095 * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2]) * u[2] + -0.095 * (x[3] + 0.095 * u[1] * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2]) * u[2]);
  B[7] = 0.16666666666666666 * (0.095 * u[2] * x[2] + -0.009025 * u[1] * pow(u[2], 2) * x[3] + 0.19 * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2] + 0.19 * u[1] * (-0.00225625 * u[1] * pow(u[2], 2) * x[2] + -0.0475 * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2] + 0.19 * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2] + 0.095 * u[1] * (-0.095 * u[1] * (-0.00225625 * u[1] * pow(u[2], 2) * x[3] + 0.0475 * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2] + -0.095 * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2]) * u[2] + 0.095 * (x[2] + -0.095 * u[1] * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2]) * u[2]);
  B[8] = 0.16666666666666666 * (0.00028500000000000004 * u[0] * x[2] + -2.7075000000000004e-5 * u[0] * u[1] * u[2] * x[3] + 0.0005700000000000001 * u[0] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) + 0.0005700000000000001 * u[0] * (-0.00225625 * pow(u[1], 2) * u[2] * x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2])) * u[2] + 0.0005700000000000001 * u[0] * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) + 0.00028500000000000004 * u[0] * (-0.095 * u[1] * (-0.00225625 * pow(u[1], 2) * u[2] * x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3])) * u[2] + -0.095 * u[1] * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2])) * u[2] + 0.00028500000000000004 * u[0] * (x[2] + -0.095 * u[1] * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2]));
  B[9] = 0.16666666666666666 * (0.00028500000000000004 * u[0] * x[3] + 0.0005700000000000001 * u[0] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) + 2.7075000000000004e-5 * u[0] * u[1] * u[2] * x[2] + 0.0005700000000000001 * u[0] * (-0.00225625 * pow(u[1], 2) * u[2] * x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3])) * u[2] + 0.0005700000000000001 * u[0] * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) + 0.00028500000000000004 * u[0] * (0.095 * u[1] * (-0.00225625 * pow(u[1], 2) * u[2] * x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2])) * u[2] + 0.095 * u[1] * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2])) * u[2] + 0.00028500000000000004 * u[0] * (x[3] + 0.095 * u[1] * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2]));
  B[10] = 0.16666666666666666 * (-0.095 * u[1] * x[3] + -0.009025 * pow(u[1], 2) * u[2] * x[2] + -0.19 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) + -0.19 * u[1] * (-0.00225625 * pow(u[1], 2) * u[2] * x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3])) * u[2] + -0.19 * u[1] * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) + -0.095 * u[1] * (0.095 * u[1] * (-0.00225625 * pow(u[1], 2) * u[2] * x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2])) * u[2] + 0.095 * u[1] * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2])) * u[2] + -0.095 * u[1] * (x[3] + 0.095 * u[1] * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2]));
  B[11] = 0.16666666666666666 * (0.095 * u[1] * x[2] + -0.009025 * pow(u[1], 2) * u[2] * x[3] + 0.19 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) + 0.19 * u[1] * (-0.00225625 * pow(u[1], 2) * u[2] * x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2])) * u[2] + 0.19 * u[1] * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) + 0.095 * u[1] * (-0.095 * u[1] * (-0.00225625 * pow(u[1], 2) * u[2] * x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3])) * u[2] + -0.095 * u[1] * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2])) * u[2] + 0.095 * u[1] * (x[2] + -0.095 * u[1] * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2]));
}

// CLARI AIS Kinematic model: SINDy, first-order polynomial TVregDiff (2024/06/01) 1:54PM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = 10Hz;
// # ==================== H_phi = 0.05; N = 2;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== inputs: [translation_control, rotation_control]
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0;
  B[1] = -0.0015500000000000002;
  B[2] = -0.025750000000000002 * x[3] + 0.025750000000000002 * (-1 * x[3] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2]) + -0.0012875000000000002 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2];
  B[3] = 0.025750000000000002 * x[2] + 0.025750000000000002 * (x[2] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3]) + -0.0012875000000000002 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3];
  B[4] = 0;
  B[5] = -0.000715;
  B[6] = -0.022900000000000004 * x[3] + 0.022900000000000004 * (-1 * x[3] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2]) + -0.0011450000000000002 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2];
  B[7] = 0.022900000000000004 * x[2] + 0.022900000000000004 * (x[2] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3]) + -0.0011450000000000002 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3];
  B[8] = 0;
  B[9] = 0;
  B[10] = 0;
  B[11] = 0;
}

// CLARI AIS Kinematic model: SINDy, first-order polynomial TVregDiff (2024/06/01) 4:06PM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = 10Hz;
// # ==================== H_phi = 0.05; N = 2;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== inputs: [translation_control, rotation_control]
// # ==================== uses the gait-averaged forward-Euler method
//////////////////// FIXED BODY VELOCITY INTEGRATION
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.0007750000000000001 * x[3] + 0.0007750000000000001 * (x[3] + 0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2]) + -0.0012875000000000002 * (-0.00602 + -0.0155 * u[0] + -0.00715 * u[1]) * x[2];
  B[1] = -0.0007750000000000001 * x[2] + -0.0007750000000000001 * (x[2] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3]) + -0.0012875000000000002 * (-0.00602 + -0.0155 * u[0] + -0.00715 * u[1]) * x[3];
  B[2] = -0.025750000000000002 * x[3] + 0.025750000000000002 * (-1 * x[3] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2]) + -0.0012875000000000002 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2];
  B[3] = 0.025750000000000002 * x[2] + 0.025750000000000002 * (x[2] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3]) + -0.0012875000000000002 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3];
  B[4] = 0.0003575 * x[3] + 0.0003575 * (x[3] + 0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2]) + -0.0011450000000000002 * (-0.00602 + -0.0155 * u[0] + -0.00715 * u[1]) * x[2];
  B[5] = -0.0003575 * x[2] + -0.0003575 * (x[2] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3]) + -0.0011450000000000002 * (-0.00602 + -0.0155 * u[0] + -0.00715 * u[1]) * x[3];
  B[6] = -0.022900000000000004 * x[3] + 0.022900000000000004 * (-1 * x[3] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2]) + -0.0011450000000000002 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2];
  B[7] = 0.022900000000000004 * x[2] + 0.022900000000000004 * (x[2] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3]) + -0.0011450000000000002 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3];
  B[8] = 0;
  B[9] = 0;
  B[10] = 0;
  B[11] = 0;
}

// CLARI AIS Kinematic model: SINDy, first-order polynomial finiteDiff (2024/06/20) 5:50PM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 10Hz;
// # ==================== H_phi = 0.1; N = 1;
// # ==================== states: [x, y, yaw]
// # ==================== inputs: [~translation_control, ~rotation_control]
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.1 * (-0.0773 * x[2] + 0.013 * x[3]);
  B[1] = 0.1 * (-0.013 * x[2] + -0.0773 * x[3]);
  B[2] = -0.004370000000000001 * x[3];
  B[3] = 0.004370000000000001 * x[2];
  B[4] = 0.1 * (0.8668 * x[2] + 0.9974 * x[3]);
  B[5] = 0.1 * (-0.9974 * x[2] + 0.8668 * x[3]);
  B[6] = 0.05123 * x[3];
  B[7] = -0.05123 * x[2];
}

// CLARI AIS Kinematic model: SINDy, first-order polynomial finiteDiff (2024/07/06) 2:53PM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 10Hz;
// # ==================== H_phi = 0.1; N = 1;
// # ==================== states: [x, y, yaw]
// # ==================== inputs: [~translation_control, ~rotation_control]
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.1 * (0.013 * sin(x[2]) + -0.0773 * cos(x[2]));
  B[1] = 0.1 * (-0.0773 * sin(x[2]) + -0.013 * cos(x[2]));
  B[2] = 0.004370000000000001;
  B[3] = 0.1 * (0.9974 * sin(x[2]) + 0.8668 * cos(x[2]));
  B[4] = 0.1 * (0.8668 * sin(x[2]) + -0.9974 * cos(x[2]));
  B[5] = -0.05123;
}

// CLARI AIS Kinematic model: SINDy, first-order polynomial finiteDiff (2024/07/21) 12:29PM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 10Hz;
// # ==================== H_phi = 0.1; N = 1;
// # ==================== states: [x, y, yaw]
// # ==================== inputs: swing and lift amplitudes and offsets (16 inputs)
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dGetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.1 * (-0.001384 * sin(x[2]) + -0.003872 * cos(x[2]));
  B[1] = 0.1 * (-0.003872 * sin(x[2]) + 0.001384 * cos(x[2]));
  B[2] = 0.10189999999999999;
  B[3] = 0.1 * (0.0001855 * sin(x[2]) + 0.003618 * cos(x[2]));
  B[4] = 0.1 * (0.003618 * sin(x[2]) + -0.0001855 * cos(x[2]));
  B[5] = -0.12210000000000001;
  B[6] = 0.1 * (-2.221e-6 * sin(x[2]) + 0.007932 * cos(x[2]));
  B[7] = 0.1 * (0.007932 * sin(x[2]) + 2.221e-6 * cos(x[2]));
  B[8] = -0.02307;
  B[9] = 0.1 * (-0.0004202 * sin(x[2]) + 0.002661 * cos(x[2]));
  B[10] = 0.1 * (0.002661 * sin(x[2]) + 0.0004202 * cos(x[2]));
  B[11] = 0.20320000000000002;
  B[12] = 0.1 * (-0.0007788 * sin(x[2]) + 0.004506 * cos(x[2]));
  B[13] = 0.1 * (0.004506 * sin(x[2]) + 0.0007788 * cos(x[2]));
  B[14] = -0.009099000000000001;
  B[15] = 0.1 * (-0.0002786 * sin(x[2]) + -0.003487 * cos(x[2]));
  B[16] = 0.1 * (-0.003487 * sin(x[2]) + 0.0002786 * cos(x[2]));
  B[17] = 0.05205;
  B[18] = 0.1 * (-3.928e-5 * sin(x[2]) + 0.006692 * cos(x[2]));
  B[19] = 0.1 * (0.006692 * sin(x[2]) + 3.928e-5 * cos(x[2]));
  B[20] = 0.09639;
  B[21] = 0.1 * (-0.0004973 * sin(x[2]) + 0.002624 * cos(x[2]));
  B[22] = 0.1 * (0.002624 * sin(x[2]) + 0.0004973 * cos(x[2]));
  B[23] = 0.05104;
  B[24] = 0.1 * (0.001249 * sin(x[2]) + -0.01506 * cos(x[2]));
  B[25] = 0.1 * (-0.01506 * sin(x[2]) + -0.001249 * cos(x[2]));
  B[26] = -0.045040000000000004;
  B[27] = 0.1 * (8.014e-5 * sin(x[2]) + 0.01044 * cos(x[2]));
  B[28] = 0.1 * (0.01044 * sin(x[2]) + -8.014e-5 * cos(x[2]));
  B[29] = 0.09095;
  B[30] = 0.1 * (0.001685 * sin(x[2]) + -0.01735 * cos(x[2]));
  B[31] = 0.1 * (-0.01735 * sin(x[2]) + -0.001685 * cos(x[2]));
  B[32] = -0.1513;
  B[33] = 0.1 * (0.0003461 * sin(x[2]) + -0.007047 * cos(x[2]));
  B[34] = 0.1 * (-0.007047 * sin(x[2]) + -0.0003461 * cos(x[2]));
  B[35] = -0.23050000000000004;
  B[36] = 0.1 * (0.000237 * sin(x[2]) + 4.002e-5 * cos(x[2]));
  B[37] = 0.1 * (4.002e-5 * sin(x[2]) + -0.000237 * cos(x[2]));
  B[38] = -0.02794;
  B[39] = 0.1 * (-0.0001387 * sin(x[2]) + 0.005165 * cos(x[2]));
  B[40] = 0.1 * (0.005165 * sin(x[2]) + 0.0001387 * cos(x[2]));
  B[41] = 0.18520000000000003;
  B[42] = 0.1 * (0.0002612 * sin(x[2]) + -0.001332 * cos(x[2]));
  B[43] = 0.1 * (-0.001332 * sin(x[2]) + -0.0002612 * cos(x[2]));
  B[44] = -0.06948;
  B[45] = 0.1 * (-0.0007736 * sin(x[2]) + -0.00485 * cos(x[2]));
  B[46] = 0.1 * (-0.00485 * sin(x[2]) + 0.0007736 * cos(x[2]));
  B[47] = 0.05795;
}

// HAMRV6 Kinematic model: SINDy, first-order polynomial centralAdaptivefiniteDiff (2024/12/17) 6:18PM
// # ==================== gait frequency = 5Hz and TinyMPC frequency = 5Hz;
// # ==================== H_phi = 0.2; N = 1;
// # ==================== states: [x, y, cos(yaw), sin(yaw)] # planar location and a phasor for orientation
// # ==================== inputs: 3 inputs: 2 from the experimental maneurverability model paper and 1 for amplitude change
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_HAMRv6GetJacobianB_Raw(double* B, const double* x, const double* u) {
  B[0] = 0.2 * (0.01537 * x[2] + -0.03835 * x[3]);
  B[1] = 0.2 * (0.03835 * x[2] + 0.01537 * x[3]);
  B[2] = -0.03128 * x[3];
  B[3] = 0.03128 * x[2];
  B[4] = 0.2 * (0.002067 * x[2] + -0.01061 * x[3]);
  B[5] = 0.2 * (0.01061 * x[2] + 0.002067 * x[3]);
  B[6] = -0.018364000000000002 * x[3];
  B[7] = 0.018364000000000002 * x[2];
  B[8] = 0.2 * (0.0006823 * x[2] + -0.005287 * x[3]);
  B[9] = 0.2 * (0.005287 * x[2] + 0.0006823 * x[3]);
  B[10] = -0.012458 * x[3];
  B[11] = 0.012458 * x[2];
}

