#include <math.h>
void tiny_Bicycle3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = 0.16666666666666666 * (0.4 * cos(0.05 * tan(u[1]) * u[0] + x[2]) * u[0] + 0.1 * cos(0.1 * tan(u[1]) * u[0] + x[2]) * u[0] + 0.1 * cos(x[2]) * u[0]) + x[0];
  xn[1] = 0.16666666666666666 * (0.4 * sin(0.05 * tan(u[1]) * u[0] + x[2]) * u[0] + 0.1 * sin(0.1 * tan(u[1]) * u[0] + x[2]) * u[0] + 0.1 * sin(x[2]) * u[0]) + x[1];
  xn[2] = 0.09999999999999999 * tan(u[1]) * u[0] + x[2];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/04/25) 11:10AM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 5Hz; H = 0.2;
// # ==================== uses the typical midpoint method
#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.00028500000000000004 * u[0] * cos(0.0475 * u[1] + x[2]);
  xn[1] = x[1] + 0.00028500000000000004 * u[0] * sin(0.0475 * u[1] + x[2]);
  xn[2] = 0.095 * u[1] + x[2];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/04/30) 10:13AM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 5Hz;
// # ==================== H = 0.2; H_phi = 0.1; N = 2;
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.00028500000000000004 * u[0] * cos(0.095 * u[1] + x[2]) + 0.00028500000000000004 * u[0] * cos(x[2]);
  xn[1] = x[1] + 0.00028500000000000004 * u[0] * sin(0.095 * u[1] + x[2]) + 0.00028500000000000004 * u[0] * sin(x[2]);
  xn[2] = 0.19 * u[1] + x[2];
}

// CLARI AIS Kinematic model (2024/04/30) 10:38AM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 5Hz;
// # ==================== H = 0.2; H_phi = 0.1; N = 2;
// # ==================== uses the gait-averaged midpoint method
#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.00028500000000000004 * u[0] * cos(0.095 * u[1] + x[2]) + 0.00028500000000000004 * u[0] * cos(0.19 * u[1] + x[2]);
  xn[1] = x[1] + 0.00028500000000000004 * u[0] * sin(0.095 * u[1] + x[2]) + 0.00028500000000000004 * u[0] * sin(0.19 * u[1] + x[2]);
  xn[2] = 0.19 * u[1] + x[2];
}

// CLARI AIS Kinematic model (2024/04/30) 10:49AM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 5Hz;
// # ==================== H = 0.2; H_phi = 0.1; N = 2;
// # ==================== uses the gait-averaged RK4 method
#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.16666666666666666 * (0.00028500000000000004 * u[0] * cos(0.28500000000000003 * u[1] + x[2]) + 0.00028500000000000004 * u[0] * cos(0.095 * u[1] + x[2]) + 4 * (0.00028500000000000004 * u[0] * cos(0.095 * u[1] + x[2]) + 0.00028500000000000004 * u[0] * cos(0.19 * u[1] + x[2])) + 0.00028500000000000004 * u[0] * cos(0.19 * u[1] + x[2]) + 0.00028500000000000004 * u[0] * cos(x[2]));
  xn[1] = x[1] + 0.16666666666666666 * (0.00028500000000000004 * u[0] * sin(0.095 * u[1] + x[2]) + 4 * (0.00028500000000000004 * u[0] * sin(0.095 * u[1] + x[2]) + 0.00028500000000000004 * u[0] * sin(0.19 * u[1] + x[2])) + 0.00028500000000000004 * u[0] * sin(0.19 * u[1] + x[2]) + 0.00028500000000000004 * u[0] * sin(x[2]) + 0.00028500000000000004 * u[0] * sin(0.28500000000000003 * u[1] + x[2]));
  xn[2] = 0.19 * u[1] + x[2];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/04/30) 4:40PM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = 10Hz;
// # ==================== H = 0.1; H_phi = 0.05; N = 2;
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.00014250000000000002 * u[0] * cos(0.0475 * u[1] + x[2]) + 0.00014250000000000002 * u[0] * cos(x[2]);
  xn[1] = x[1] + 0.00014250000000000002 * u[0] * sin(x[2]) + 0.00014250000000000002 * u[0] * sin(0.0475 * u[1] + x[2]);
  xn[2] = 0.095 * u[1] + x[2];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/04/30) 5:14PM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = 10Hz;
// # ==================== H = 0.1; H_phi = 0.05; N = 2;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.00014250000000000002 * u[0] * x[2] + 0.00014250000000000002 * u[0] * (x[2] + -0.0475 * u[1] * x[3]);
  xn[1] = x[1] + 0.00014250000000000002 * u[0] * x[3] + 0.00014250000000000002 * u[0] * (x[3] + 0.0475 * u[1] * x[2]);
  xn[2] = x[2] + -0.0475 * u[1] * x[3] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * x[2]);
  xn[3] = x[3] + 0.0475 * u[1] * x[2] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * x[3]);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/05/01) 8:00AM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = 20Hz;
// # ==================== H = 0.05; H_phi = 0.05; N = 1;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.00014250000000000002 * u[0] * x[2];
  xn[1] = x[1] + 0.00014250000000000002 * u[0] * x[3];
  xn[2] = x[2] + -0.0475 * u[1] * x[3];
  xn[3] = x[3] + 0.0475 * u[1] * x[2];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/05/03) 1:48AM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = 20Hz;
// # ==================== H = 0.05; H_phi = 0.05; N = 1;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== inputs: [translation_control, rotation_control, swing_control]
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.00014250000000000002 * u[0] * u[2] * x[2];
  xn[1] = x[1] + 0.00014250000000000002 * u[0] * u[2] * x[3];
  xn[2] = x[2] + -0.0475 * u[1] * u[2] * x[3];
  xn[3] = x[3] + 0.0475 * u[1] * u[2] * x[2];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model (2024/05/05) 9:29PM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = <NOT_CONSTRAINED>;
// # ==================== H_phi = 0.05; N = <UNKNOWN>;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== inputs: [translation_control, rotation_control, swing_control]
// # ==================== uses the rk4 method
#include <math.h>
void tiny_Bicycle3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.16666666666666666 * (0.00028500000000000004 * u[0] * u[2] * x[2] + 0.0005700000000000001 * u[0] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2] + 0.0005700000000000001 * u[0] * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2] + 0.00028500000000000004 * u[0] * (x[2] + -0.095 * u[1] * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2]) * u[2]);
  xn[1] = x[1] + 0.16666666666666666 * (0.00028500000000000004 * u[0] * u[2] * x[3] + 0.0005700000000000001 * u[0] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2] + 0.0005700000000000001 * u[0] * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2] + 0.00028500000000000004 * u[0] * (x[3] + 0.095 * u[1] * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2]) * u[2]);
  xn[2] = x[2] + 0.16666666666666666 * (-0.095 * u[1] * u[2] * x[3] + -0.19 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2] + -0.19 * u[1] * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2] + -0.095 * u[1] * (x[3] + 0.095 * u[1] * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2]) * u[2]);
  xn[3] = x[3] + 0.16666666666666666 * (0.095 * u[1] * u[2] * x[2] + 0.19 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2] + 0.19 * u[1] * (x[2] + -0.0475 * u[1] * (x[3] + 0.0475 * u[1] * u[2] * x[2]) * u[2]) * u[2] + 0.095 * u[1] * (x[2] + -0.095 * u[1] * (x[3] + 0.0475 * u[1] * (x[2] + -0.0475 * u[1] * u[2] * x[3]) * u[2]) * u[2]) * u[2]);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CLARI AIS Kinematic model: SINDy, first-order polynomial TVregDiff (2024/06/01) 1:54PM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = 10Hz;
// # ==================== H_phi = 0.05; N = 2;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== inputs: [translation_control, rotation_control]
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0];
  xn[1] = 0.1 * (-0.00602 + -0.0155 * u[0] + -0.00715 * u[1]) + x[1];
  xn[2] = x[2] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3] + 0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * (-1 * x[3] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2]);
  xn[3] = x[3] + 0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2] + 0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * (x[2] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3]);
}

// CLARI AIS Kinematic model: SINDy, first-order polynomial TVregDiff (2024/06/01) 4:06PM
// # ==================== gait frequency = 20Hz and TinyMPC frequency = 10Hz;
// # ==================== H_phi = 0.05; N = 2;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== inputs: [translation_control, rotation_control]
// # ==================== uses the gait-averaged forward-Euler method
//////////////////// FIXED BODY VELOCITY INTEGRATION
#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + -0.05 * (-0.00602 + -0.0155 * u[0] + -0.00715 * u[1]) * x[3] + -0.05 * (-0.00602 + -0.0155 * u[0] + -0.00715 * u[1]) * (x[3] + 0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2]);
  xn[1] = x[1] + 0.05 * (-0.00602 + -0.0155 * u[0] + -0.00715 * u[1]) * x[2] + 0.05 * (-0.00602 + -0.0155 * u[0] + -0.00715 * u[1]) * (x[2] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3]);
  xn[2] = x[2] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3] + 0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * (-1 * x[3] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2]);
  xn[3] = x[3] + 0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[2] + 0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * (x[2] + -0.05 * (0.0213 + 0.515 * u[0] + 0.458 * u[1]) * x[3]);
}

// CLARI AIS Kinematic model: SINDy, first-order polynomial finiteDiff (2024/06/20) 5:50PM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 10Hz;
// # ==================== H_phi = 0.1; N = 1;
// # ==================== states: [x, y, cos(yaw), sin(yaw)]
// # ==================== inputs: [~translation_control, ~rotation_control]
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.1 * ((0.0263 + -0.0773 * u[0] + 0.8668 * u[1]) * x[2] + -1 * (-0.0008 + -0.013 * u[0] + -0.9974 * u[1]) * x[3]);
  xn[1] = x[1] + 0.1 * ((-0.0008 + -0.013 * u[0] + -0.9974 * u[1]) * x[2] + (0.0263 + -0.0773 * u[0] + 0.8668 * u[1]) * x[3]);
  xn[2] = x[2] + -0.1 * (-0.001 + 0.0437 * u[0] + -0.5123 * u[1]) * x[3];
  xn[3] = x[3] + 0.1 * (-0.001 + 0.0437 * u[0] + -0.5123 * u[1]) * x[2];
}

// CLARI AIS Kinematic model: SINDy, first-order polynomial finiteDiff (2024/07/06) 2:53PM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 10Hz;
// # ==================== H_phi = 0.1; N = 1;
// # ==================== states: [x, y, yaw]
// # ==================== inputs: [~translation_control, ~rotation_control]
// # ==================== uses the gait-averaged forward-Euler method#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.1 * (-1 * (-0.0008 + -0.013 * u[0] + -0.9974 * u[1]) * sin(x[2]) + (0.0263 + -0.0773 * u[0] + 0.8668 * u[1]) * cos(x[2]));
  xn[1] = x[1] + 0.1 * ((0.0263 + -0.0773 * u[0] + 0.8668 * u[1]) * sin(x[2]) + (-0.0008 + -0.013 * u[0] + -0.9974 * u[1]) * cos(x[2]));
  xn[2] = 0.1 * (-0.001 + 0.0437 * u[0] + -0.5123 * u[1]) + x[2];
}

// CLARI AIS Kinematic model: SINDy, first-order polynomial finiteDiff (2024/07/21) 12:29PM
// # ==================== gait frequency = 10Hz and TinyMPC frequency = 10Hz;
// # ==================== H_phi = 0.1; N = 1;
// # ==================== states: [x, y, yaw]
// # ==================== inputs: swing and lift amplitudes and offsets (16 inputs)
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_CLARI3dNonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.1 * (-1 * (-0.000519 + 0.001384 * u[0] + -8.014e-5 * u[9] + -0.001685 * u[10] + -0.0003461 * u[11] + -0.000237 * u[12] + 0.0001387 * u[13] + -0.0002612 * u[14] + 0.0007736 * u[15] + -0.0001855 * u[1] + 2.221e-6 * u[2] + 0.0004202 * u[3] + 0.0007788 * u[4] + 0.0002786 * u[5] + 3.928e-5 * u[6] + 0.0004973 * u[7] + -0.001249 * u[8]) * sin(x[2]) + (0.00538 + -0.003872 * u[0] + 0.01044 * u[9] + -0.01735 * u[10] + -0.007047 * u[11] + 4.002e-5 * u[12] + 0.005165 * u[13] + -0.001332 * u[14] + -0.00485 * u[15] + 0.003618 * u[1] + 0.007932 * u[2] + 0.002661 * u[3] + 0.004506 * u[4] + -0.003487 * u[5] + 0.006692 * u[6] + 0.002624 * u[7] + -0.01506 * u[8]) * cos(x[2]));
  xn[1] = x[1] + 0.1 * ((0.00538 + -0.003872 * u[0] + 0.01044 * u[9] + -0.01735 * u[10] + -0.007047 * u[11] + 4.002e-5 * u[12] + 0.005165 * u[13] + -0.001332 * u[14] + -0.00485 * u[15] + 0.003618 * u[1] + 0.007932 * u[2] + 0.002661 * u[3] + 0.004506 * u[4] + -0.003487 * u[5] + 0.006692 * u[6] + 0.002624 * u[7] + -0.01506 * u[8]) * sin(x[2]) + (-0.000519 + 0.001384 * u[0] + -8.014e-5 * u[9] + -0.001685 * u[10] + -0.0003461 * u[11] + -0.000237 * u[12] + 0.0001387 * u[13] + -0.0002612 * u[14] + 0.0007736 * u[15] + -0.0001855 * u[1] + 2.221e-6 * u[2] + 0.0004202 * u[3] + 0.0007788 * u[4] + 0.0002786 * u[5] + 3.928e-5 * u[6] + 0.0004973 * u[7] + -0.001249 * u[8]) * cos(x[2]));
  xn[2] = 0.1 * (-2.069 + 1.019 * u[0] + 0.9095 * u[9] + -1.513 * u[10] + -2.305 * u[11] + -0.2794 * u[12] + 1.852 * u[13] + -0.6948 * u[14] + 0.5795 * u[15] + -1.221 * u[1] + -0.2307 * u[2] + 2.032 * u[3] + -0.09099 * u[4] + 0.5205 * u[5] + 0.9639 * u[6] + 0.5104 * u[7] + -0.4504 * u[8]) + x[2];
}

// HAMRV6 Kinematic model: SINDy, first-order polynomial centralAdaptivefiniteDiff (2024/12/17) 6:22PM
// # ==================== gait frequency = 5Hz and TinyMPC frequency = 5Hz;
// # ==================== H_phi = 0.2; N = 1;
// # ==================== states: [x, y, cos(yaw), sin(yaw)] # planar location and a phasor for orientation
// # ==================== inputs: 3 inputs: 2 from the experimental maneurverability model paper and 1 for amplitude change
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_HAMRv6NonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.2 * ((0.01537 * u[0] + 0.002067 * u[1] + 0.0006823 * u[2]) * x[2] + -1 * (0.03835 * u[0] + 0.01061 * u[1] + 0.005287 * u[2]) * x[3]);
  xn[1] = x[1] + 0.2 * ((0.03835 * u[0] + 0.01061 * u[1] + 0.005287 * u[2]) * x[2] + (0.01537 * u[0] + 0.002067 * u[1] + 0.0006823 * u[2]) * x[3]);
  xn[2] = x[2] + -0.2 * (0.1564 * u[0] + 0.09182 * u[1] + 0.06229 * u[2]) * x[3];
  xn[3] = x[3] + 0.2 * (0.1564 * u[0] + 0.09182 * u[1] + 0.06229 * u[2]) * x[2];
}

// HAMRV6 Kinematic model: SINDy, first-order polynomial centralAdaptivefiniteDiff (2024/12/18) 5:43PM
// # ==================== gait frequency = 5Hz and TinyMPC frequency = 2.5Hz;
// # ==================== H_phi = 0.2; N = 2;
// # ==================== states: [x, y, cos(yaw), sin(yaw)] # planar location and a phasor for orientation
// # ==================== inputs: 3 inputs: 2 from the experimental maneurverability model paper and 1 for amplitude change
// # ==================== uses the gait-averaged forward-Euler method
#include <math.h>
void tiny_HAMRv6NonlinearDynamics_Raw(double* xn, const double* x, const double* u) {
  xn[0] = x[0] + 0.2 * ((0.01537 * u[0] + 0.002067 * u[1] + 0.0006823 * u[2]) * x[2] + -1 * (0.03835 * u[0] + 0.01061 * u[1] + 0.005287 * u[2]) * x[3]) + 0.2 * (-1 * (0.03835 * u[0] + 0.01061 * u[1] + 0.005287 * u[2]) * (x[3] + 0.2 * (0.1564 * u[0] + 0.09182 * u[1] + 0.06229 * u[2]) * x[2]) + (0.01537 * u[0] + 0.002067 * u[1] + 0.0006823 * u[2]) * (x[2] + -0.2 * (0.1564 * u[0] + 0.09182 * u[1] + 0.06229 * u[2]) * x[3]));
  xn[1] = x[1] + 0.2 * ((0.03835 * u[0] + 0.01061 * u[1] + 0.005287 * u[2]) * x[2] + (0.01537 * u[0] + 0.002067 * u[1] + 0.0006823 * u[2]) * x[3]) + 0.2 * ((0.01537 * u[0] + 0.002067 * u[1] + 0.0006823 * u[2]) * (x[3] + 0.2 * (0.1564 * u[0] + 0.09182 * u[1] + 0.06229 * u[2]) * x[2]) + (0.03835 * u[0] + 0.01061 * u[1] + 0.005287 * u[2]) * (x[2] + -0.2 * (0.1564 * u[0] + 0.09182 * u[1] + 0.06229 * u[2]) * x[3]));
  xn[2] = x[2] + -0.2 * (0.1564 * u[0] + 0.09182 * u[1] + 0.06229 * u[2]) * x[3] + 0.2 * (0.1564 * u[0] + 0.09182 * u[1] + 0.06229 * u[2]) * (-1 * x[3] + -0.2 * (0.1564 * u[0] + 0.09182 * u[1] + 0.06229 * u[2]) * x[2]);
  xn[3] = x[3] + 0.2 * (0.1564 * u[0] + 0.09182 * u[1] + 0.06229 * u[2]) * x[2] + 0.2 * (0.1564 * u[0] + 0.09182 * u[1] + 0.06229 * u[2]) * (x[2] + -0.2 * (0.1564 * u[0] + 0.09182 * u[1] + 0.06229 * u[2]) * x[3]);
}

